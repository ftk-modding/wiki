# Getting started

This is short guide to get things started on FTK mod development. Knowledge of C# programming language is required and at least basic understanding of Unity base concepts is recommended.

## Bepinex installation

To inject your logic into the game, you have to install Bepinex. You can follow this guide to do this: https://docs.bepinex.dev/articles/user_guide/installation/index.html.
You can download it from [Bepinex release page](https://github.com/BepInEx/BepInEx/releases/tag/v5.4.19). Most probably you'll need BepInEx_x64_5.4.19.0.zip.

Bepinex will allow you to put your plugins into Bepinex/plugins directory that would be executed on game launch.

## Plugin creation

To create plugin you can either use FTK plugin template from [templates repository](https://github.com/ftk-modding/templates) or use [Bepinex guide](https://docs.bepinex.dev/articles/dev_guide/plugin_tutorial/index.html).

> **If you choose using bepinex manual**: FTK Unity version is 2017.2.2f, supported .NET version is 3.5. You'll also want to download and reference dlls from [stripped-binaries](https://github.com/ftk-modding/stripped-binaries) repository. Those includes publicized and stripped binaries from the game as well as autogenerated [MonoMod](https://github.com/MonoMod/MonoMod) HookGen hooks.

Now you have basic plugin that does nothing except logging. Feel free to build it and put to `Bepinex/plugins` directory to check that log message "Plugin YourPluginName is loaded!" is displayed and everything is working correctly.

Let's see how to add some actual logic.

## Plugin logic

In order to add/change in-game logic, we can use hooks. Those hooks can be done with Harmony library bundled with Bepinex or by using autogenerated [MonoMod's HookGen](https://github.com/MonoMod/MonoMod/blob/master/README-RuntimeDetour.md#using-hookgen) hooks `MMHOOK_Assembly-CSharp.dll` included in `stripped-binaries` repository. Usually, you'll use only one of approaches. General guide: [Bepinex: Runtime patching](https://docs.bepinex.dev/articles/dev_guide/runtime_patching.html). Examples below will be using `MMHOOK`.

Let's use [Debugging Commands](https://for-the-king.thunderstore.io/package/Amadare/DebuggingCommands/) as an example how to implement simple mod.

In this mod we want to intercept chat messages and invoke our custom logic if message is custom command. If that is custom command, we'll prevent posting it to the chat. Here how this is done (code is slightly modified for clarity):

```c#
private void Awake()
{
    // ...
    On.uiChatBox.OnInputFinished += UiChatBoxOnOnInputFinished
}

private void UiChatBoxOnOnInputFinished(On.uiChatBox.orig_OnInputFinished orig, uiChatBox self, string _s)
{
    var isCommand = CheckCommand(_s);
    if (!isCommand)
    {
        orig(self, _s);
    }
}

private bool CheckCommand(string message) {
    // ..
    // if message is defined command, execute it and return true
    // else return false
}
```

What it means is there is class `uiChatBox` in FTK files with method `InputFinished` that has one argument `string _s`. We are intercepting all calls to it from game logic and able to add logic before or after original implementation using our code. First argument of any `On.` event is always original method implementation `orig` and instance of object `self`.
So in our implementation, we'll apply our command logic and call original implementation (here: posting message in chat) only if message wasn't actual command.

In this case we wanted to cancel calling original implementation, but generally you'll want to call `orig` method in your every hook so actual in-game logic and other hooks would be executed.

> NOTE: in order to use those hooks, they should be loaded with your plugin. To avoid having to provide MMHOOKs with each plugin, you can add dependency to Amadare-HookGenPatcher-1.2.1 plugin that will generate it automatically on game run.
> 
> It is included in plugin template. 

## Decompiling

But how can you find which methods to override? For that you'll have to decompile game dll. In Unity usually all logic is compiled to `Assembly-CSharp.dll` file. It can be found in `For The King\FTK_Data\Managed\Assembly-CSharp.dll`. To decompile it, you can use [ilspy](https://github.com/icsharpcode/ILSpy/releases/tag/v7.2) that can export it to csproj file that can be browsed using IDE of your choice. All private members are accessible from plugin if created correctly.

To extract Unity assets you can use [AssetRipper](https://github.com/AssetRipper/AssetRipper). It will generate Unity project where you can browse through scenes and assets using UnityEditor of same version as a game (2017.2.2f).
> NOTE: currently there are some problems that doesn't allow to extract all game assets and process is failing with an error. But this potentially can be fixed with [this issue](https://github.com/AssetRipper/AssetRipper/issues/164)

## Exploring in runtime

I would also recommend installing [Unity Explorer](https://github.com/sinai-dev/UnityExplorer)([download](https://github.com/sinai-dev/UnityExplorer/releases/download/4.6.1/UnityExplorer.BepInEx5.Mono.zip)) plugin that, beside other features can:
- inspect GameObjects and their Components along with their values
- invoke functions from components
- write and evaluate C# expressions during runtime

Those features could be very helpful for object investigation and debugging.

## Debugging

You can also debug game (with watches and breakpoints) using dnSpy. Please follow this [guide](https://github.com/dnSpy/dnSpy/wiki/Debugging-Unity-Games) to do that. 

> Note: releases of patched versions of mono runtime are not available using links in this guide. You can use one from [this repo](https://github.com/wh0am15533/Patched-Unity-Mono). Here is [download link](https://github.com/wh0am15533/Patched-Unity-Mono/raw/main/CustomBuilds/Unity-debugging-2017.x/unity-2017.2.2.rar) to correct binaries.


## Adding in-game configuration and custom content FTKAPI

You may want to add dependency to [FTKAPI](https://for-the-king.thunderstore.io/package/Amadare/FTKAPI/) plugin. It is WIP project, but can provide following functionality:

- add custom Assets
- add custom Items
- add custom Classes
- add configuration for plugin values to in-game options menu (currently only checkboxes are supported) 
- add network objects for multiplayer synchronisation